<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8" />
</head>

<body style="background: gray; color: #888888">
    <script id="vertexshader" , type="x-shader/x-vertex">
        precision highp float;
        
        // Run a vertex shader instance for each depth data point to create
        // 3D model of the data (pointcloud).
        ////////////////////////////////////////////////////////////////////
        // Parameters of the currently used camera, see
        // https://github.com/IntelRealSense/librealsense/blob/master/doc/projection.md
        // and the documentation at
        // https://w3c.github.io/mediacapture-depth/#synchronizing-depth-and-color-video-rendering
        // The possible values for u_depth_distortion_model and
        // u_color_distortion_model.
        // https://github.com/IntelRealSense/librealsense/blob/master/doc/projection.md#distortion-models
        
        #define DISTORTION_NONE 0
        #define DISTORTION_MODIFIED_BROWN_CONRADY 1
        #define DISTORTION_INVERSE_BROWN_CONRADY 2
        
        // Matrix that represents the transformation to be done between the
        // depth data 3D position to the color data 3D position.
        uniform mat4 u_depth_to_color;
        
        // Used to convert the raw depth data into meters.
        // Corresponds to `rs_get_device_depth_scale()` in librealsense.
        uniform float u_depth_scale;
        
        // Center of projection of the depth camera data.
        uniform vec2 u_depth_offset;
        
        // Focal length of the depth data.
        uniform vec2 u_depth_focal_length;
        
        // See the comment for the DISTORTION_* constants
        uniform int u_depth_distortion_model;
        
        // If the depth distortion model is not DISTORTION_NONE, set these
        // to numbers that describe the distortion.
        uniform float u_depth_distortion_coeffs[5];
        
        // Center of projection of the color data.
        uniform vec2 u_color_offset;
        
        // Focal length of the color data.
        uniform vec2 u_color_focal_length;
        
        // See the comment for the DISTORTION_* constants
        uniform int u_color_distortion_model;
        
        // If the color distortion model is not DISTORTION_NONE, set these
        // to numbers that describe the distortion.
        uniform float u_color_distortion_coeffs[5];
        ////////////////////////////////////////////////////////////////////
        
        // Model-View-Projection matrix.
        uniform mat4 u_mvp;

        // All of the depth data.
        uniform sampler2D u_depth_texture;

        // Index of the depth_texture pixel that we are processing in this
        // instance of the shader. Calculated outside of the shader, because
        // OpenGL ES doesn't support gl_VertexId. Ranges from [0, 0] to
        // [u_depth_texture_size.x, u_depth_texture_size.y].
        attribute vec2 a_depth_texture_index;

        // Width and height of the depth data.
        uniform vec2 u_depth_texture_size;
        
        // Width and height of the color data.
        uniform vec2 u_color_texture_size;

        uniform float nearClipping, farClipping;

        // Coordinate in the color texture for the vertex processed in the
        // vertex shader that will be passed to the fragment shader.
        varying vec2 v_color_texture_coord;

        varying vec2 vUv;

        // Convert the index of the depth data (ranged from [0, 0] to
        // [u_depth_texture_size.x, u_depth_texture_size.y]) into a position
        // in 3D space. The `depth` parameter needs to be in meters.
        // This should be equivalent to what `rs_deproject_pixel_to_point()`
        // in librealsense does.
        vec4 depth_deproject(vec2 index, float depth) {
            vec2 position2d = (index - u_depth_offset) / u_depth_focal_length;
            if(u_depth_distortion_model == DISTORTION_INVERSE_BROWN_CONRADY) {
                float r2 = dot(position2d, position2d);
                float f = 1.0
                        + u_depth_distortion_coeffs[0] * r2
                        + u_depth_distortion_coeffs[1] * r2 * r2
                        + u_depth_distortion_coeffs[4] * r2 * r2 * r2;
                float ux = position2d.x * f
                         + 2.0 * u_depth_distortion_coeffs[2] * position2d.x * position2d.y
                         + u_depth_distortion_coeffs[3] * (r2 + 2.0 * position2d.x * position2d.x);
                float uy = position2d.y * f
                         + 2.0 * u_depth_distortion_coeffs[3] * position2d.x * position2d.y
                         + u_depth_distortion_coeffs[2] * (r2 + 2.0 * position2d.y * position2d.y);
                position2d = vec2(ux, uy);
          }
          return vec4(position2d * depth, depth, 1.0);
        }

        // Convert the 3D position of the color data into an index to the
        // color data array. In an ideal world, the output would be ranged
        // from [0, 0] to [u_color_texture_size.x, u_color_texture_size.y].
        // Since the RGB camera often has a smaller field of view than the
        // depth camera, the result could be outside of this range, meaning
        // that the RGB data for that 3D coordinate are missing.
        //
        // This should be equivalent to what `rs_project_point_to_pixel()`
        // in librealsense does.
        vec2 color_project(vec4 position3d) {
            vec2 position2d = position3d.xy / position3d.z;
            if(u_color_distortion_model == DISTORTION_MODIFIED_BROWN_CONRADY) {
                float r2 = dot(position2d, position2d);
                float f = 1.0
                        + u_color_distortion_coeffs[0] * r2
                        + u_color_distortion_coeffs[1] * r2 * r2
                        + u_color_distortion_coeffs[4] * r2 * r2 * r2;
                position2d = position2d * f;
                float dx = position2d.x
                         + 2.0 * u_color_distortion_coeffs[2] * position2d.x * position2d.y
                         + u_color_distortion_coeffs[3] * (r2 + 2.0 * position2d.x * position2d.x);
                float dy = position2d.y
                         + 2.0 * u_color_distortion_coeffs[3] * position2d.x * position2d.y
                         + u_color_distortion_coeffs[2] * (r2 + 2.0 * position2d.y * position2d.y);
                position2d = vec2(dx, dy);
            }
            return position2d * u_color_focal_length + u_color_offset;
        }

        void main() {
            vec2 depth_texture_coord = a_depth_texture_index / u_depth_texture_size;
            vUv = depth_texture_coord;
            vec4 color = texture2D(u_depth_texture, depth_texture_coord);
            float depth = (color.a + color.b * 16.0 + color.g * 16.0 * 16.0 + color.r * 16.0 * 16.0 * 16.0);
            // For example, a value of 1.5 means the current point is 1.5 meters away.
            float depth_scaled = u_depth_scale * depth;

            // X and Y are the position within the depth texture (adjusted
            // so that it matches the position of the RGB texture), Z is
            // the depth.
            vec4 position = depth_deproject(a_depth_texture_index, depth_scaled);

            gl_PointSize = 2.0;
            gl_Position = projectionMatrix * modelViewMatrix * position;
        }
    </script>
    <script id="fragmentshader" type="x-shader/x-fragment">
        uniform sampler2D u_depth_texture;
        varying vec2 vUv;
        void main() {
            vec4 color = texture2D( u_depth_texture, vUv );
            gl_FragColor = vec4( 1.0, 0, 0, 1.0 );
        }
    </script>
    <div class='conrols' style="background: white; height: 100px; width: 100%;">

        <button id="webrtcConnectButton" onclick="connectButtonClicked()">
            connect
        </button>
        <button id="webrtcDisconnectButton" onclick="disconnectButtonClicked()">
            disconnect
        </button>

    </div>
    <div style="background: gray; height: 10px; width: 100%">
    </div>
    <script src="../dist/main.js"></script>
</body>

</html>